<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haoyu Li on Jet&#39;s Home</title>
    <link>https://learjet5.github.io/</link>
    <description>Recent content in Haoyu Li on Jet&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Nov 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://learjet5.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Datacon记录</title>
      <link>https://learjet5.github.io/blogs/datacon%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 20 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://learjet5.github.io/blogs/datacon%E8%AE%B0%E5%BD%95/</guid>
      <description>简介 2022年12月当时在打物联网安全赛道，用实验室先前论文SFuzz的代码改改，能较好地解决RTOS固件的相关题目，但第三题整数溢出漏洞检测在短时间内写出来的工具还是效果不佳。&#xA;2023年11月又带学弟们打了漏洞分析赛道，前两题基本是苦力活，第三题挖0day因为没提前买设备and固件模拟不熟练导致写不出exp，略遗憾。&#xA;后面如果再打Datacon的话就只想直接做第三题了（瘫&#xA;IDA脚本 人工审计二进制代码漏洞时，需要快速判断source点到sink点之间是否存在call trace。写了个简单的IDA脚本实现这一功能。&#xA;import idautils import idc import ida_idp import ida_funcs import ida_nalt import time log_file = None # # Basic Tools # def printh(num): # h = hex print(hex(num)) def printh_list(nums): for num in nums: printh(num) def printf(func_ea): # f = funtion name = idc.get_func_name(func_ea) if name: print(&amp;#34;%s(%s)&amp;#34; % (name, hex(func_ea))) def get_addr_32(num)-&amp;gt;str: s = hex(num)[2:] return &amp;#39;0x&amp;#39; + s.rjust(8, &amp;#39;0&amp;#39;) def is_func_entry(ea): func = ida_funcs.</description>
    </item>
    <item>
      <title>Android APP抓包方案调研</title>
      <link>https://learjet5.github.io/blogs/android-app-%E6%8A%93%E5%8C%85%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</link>
      <pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://learjet5.github.io/blogs/android-app-%E6%8A%93%E5%8C%85%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</guid>
      <description>1. 背景 在移动安全研究中，如果要对一个APP进行逆向分析、进而了解其交互行为，流量分析是非常重要的一个手段。&#xA;而Android APP流量分析虽然是一个老生常谈的话题，但其中仍有许多坑点。同时，对于以下这些特殊情况，常见的抓包手段可能并不适用，比如：&#xA;没有安卓真机的苹果用户； 需要进行长期自动化流量分析的研究人员； 对国际APP（需要额外配置科学上网代理才能正常使用的APP）有分析需求的研究人员。 针对不同需求场景和硬件条件，本文介绍了两种安卓手机APP流量抓取方案，能够达到较为稳定的抓包效果。&#xA;2. 技术路线 2.1 Redroid云手机 + LAMDA框架 LAMDA框架是一个用于安卓逆向及自动化的辅助框架，集成了多种功能。LAMDA的服务端需要在待控制的目标安卓设备上安装，客户端则可以是任一个能运行python环境并安装了lamda模块（pip3 install -U lamda）的终端。&#xA;注意：LAMDA提供了一种客户端远程操作Android设备的方法，但LAMDA框架本身并不提供Android模拟器方案，需要用户自行准备真机或模拟器环境。&#xA;Redroid是一个安卓云手机解决方案，可以帮助研究人员在一台Linux服务器上轻松地启动多个云手机实例（比如每一个Redroid云手机实例对应一个Docker容器），其同时支持arm64和amd64架构。&#xA;在Redroid云手机模拟器中安装LAMDA服务端程序，用户即可通过Chrome浏览器访问该设备LAMDA服务的指定端口，实现基于浏览器Web页面的云手机控制，远程控制效果如下图所示。&#xA;LAMDA框架中集成了mitmproxy组件，mitmproxy是一种常用的Man-in-the-Middle（MITM）代理工具，广泛应用于网络流量的拦截、截取、查看和修改。&#xA;在本地PC上运行python lamda/tools/startmitm.py命令，即可启动mitmproxy中间人代理，LAMDA框架会自动化完成相关配置，进而把云手机的流量转发到本地PC上的代理程序，供进一步分析。mitmproxy程序还提供了Web页面，可以方便地查看所监听到的流量数据包，相关界面如下图所示。&#xA;对于需要科学上网的国际APP，此时会遇到一个问题：APP既需要设置用于科学上网的翻墙代理A，又需要设置用于抓包的中间人代理B，二者可能会相互冲突。&#xA;为了抓取国际APP的流量，可以在中间人设备中设置上游代理（upstream proxy）进一步转发流量，即在LAMDA的中间人代理程序启动时，我们通过指定upstream proxy为本地PC上的V2Ray软件（比如下图中的&amp;quot;10.10.192.147:10809&amp;quot;），来实现流量翻墙的效果。在实际操作中，也可根据需要采取其他方案，例如设置全局代理。&#xA;小结一下，Redroid云手机基于Docker容器运行，支持x86/ARM手机镜像，因此本方案能够部署在任意x86/ARM架构的服务器端，配置也相对简单，不需要进行额外的Root操作，对于没有安卓真机或有自动化操作需求的研究人员来说是一个不错的选择。事实上，一些安全公司的Android沙箱方案就是基于这套技术路线，以实现批量化部署和管理。&#xA;2.2 Android真机 + Burpsuite 在有Android真机的条件下，也可通过直接在真机中设置网络代理节点的方法来抓取流量。Burpsuite是用于Web 应用程序分析和攻击渗透的集成平台，包含了许多功能，这里我们主要使用其网络代理和抓包功能，以本地PC的Burpsuite客户端作为中间人代理来监听手机APP流量。具体步骤如下：&#xA;将手机连接到本地PC的热点，即把两者置于同一局域网下； 将手机的网络代理设置为本地PC的IP、端口设置Burpsuite中所设置的代理端口，例如8080； 通过手机访问http://burp，下载Burpsuite的CA证书并安装，该步骤的目的是基于CA证书对HTTPS流量进行解密； 最后打开Burpsuite的Proxy-&amp;gt;Intercept功能，即可实现对手机流量的监听。相关流量的记录可以在HTTP history选项中查看。 为了抓取国际APP的流量，与云手机方案类似，我们可在本方案中设置Burpsuite的upstream proxy为本地PC上的V2Ray软件，以实现流量翻墙的效果。也可以基于自身情况，采用其他翻墙方案。&#xA;综上，本方案只需要准备一台Root后的Android手机和一台用于流量代理的PC机，其优势在于提供了真实的运行环境，能够保证目标App的运行稳定；并且该方案的网络流量抓包方法也比较成熟，相关参考资料较多。&#xA;2.3 SSL Pinning防护 在实际场景中，许多应用会采取一些防护手段来对抗第三方的流量分析。证书锁定（SSL/TLS Pinning）就是一种常见的安全防护手段。该方案将服务器提供的SSL/TLS证书内置到移动端开发的APP客户端中，当客户端发起请求时，通过比对内置证书和服务器端证书的内容，以确定这个连接的合法性。采用这种技术的App会影响对HTTPS流量的抓取。&#xA;但针对SSL Pinning也存在一些绕过手段，比如使用LSPosed框架的如下模块可以hook相关系统函数，绕过证书检查。&#xA;但上述方案适用于采用了Android系统统一的SSL Pinning方案的App。如果APP自己实现了定制化的SSL/TLS证书检查方法，上面的通用绕过方法就行不通了。需要对各个App分别进行针对性的处理，例如定制化地修改APK的配置并进行重打包，其中还可能涉及APK签名校验不通过的问题，难度和工作量都较大。&#xA;3. Line APP抓包示例 以Line为例，演示采用“Android真机+Burpsuite”方案抓取OCR流量的过程。&#xA;首先按照上面的方案打开Burpsuite，配置好代理抓包环境，监听手机流量。然后打开Line应用的聊天界面，选择一个会话，发送一张图片：&#xA;接着点击含有唐诗内容的图片，再点击右上角的文字识别按钮（OCR功能），可以看到图片中的文字内容被成功识别：&#xA;查看Burpsuite中抓取到的数据包情况，选择最近的一个POST报文，可以看到其发送了一串编码过的数据，response报文中含有解析出来的静夜思诗句。&#xA;由此可见，该报文就是Line APP在执行OCR功能时的请求数据包，成功抓取到该流量。&#xA;参考 [1] https://github.com/rev1si0n/lamda&#xA;[2] https://github.com/remote-android/redroid-doc&#xA;[3] https://github.com/LSPosed/LSPosed&#xA;[4] https://github.</description>
    </item>
    <item>
      <title>GEEKCON2023 AVSS挑战赛 VulnParcel题解</title>
      <link>https://learjet5.github.io/blogs/vulnparcel/</link>
      <pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://learjet5.github.io/blogs/vulnparcel/</guid>
      <description>本文内容仅用于个人存档和技术交流学习，禁止使用文中内容进行未授权或恶意的攻击行为。&#xA;前言 八月份参加了AVSS挑战赛，第一次打这种Android漏洞利用的比赛，比赛的两天只写出来了APP层的expReceiver和ZipZip，和前几名的队伍相比主要是VulnParcel没写出来（其他的内核题不太会qwq），故在赛后复盘一下这道Parcel漏洞利用的题目。&#xA;赛题与exp下载链接：https://github.com/learjet5/GEEKCON2023-AVSS&#xA;在分析具体题目之前，需要先介绍一下前置知识。&#xA;Parcelable对象 在Android开发过程中，常常需要在进程间进行类对象的传递，系统一般会将这些对象放到Intent或者Bundle里面进行数据传递，这一过程中就会涉及序列化和反序列化的操作。其中，序列化是将对象转换为可以传输的二进制流（二进制序列）的过程，这样我们就可以将结构化数据转化为可以在网络传输或者保存到本地的流（序列），从而进行数据传输；反序列化则是从二进制流（序列）恢复出类对象的过程。&#xA;Parcelable是Android为开发者提供的序列化的接口，其相对于Serializable接口的使用相对复杂一些，但Parcelable的效率也要比Serializable高得多。一个类要想支持序列化的数据传输，就需要实现Parcelable接口。Parcelable接口的实现类必须要有一个非空的静态变量 CREATOR 用于从Parcel中恢复原始对象，其重载了createFromParcel函数；同时也需要重载接口中的两个函数：writeToParcel用于将原始对象序列化并写入Parcel，describeContents只针对一些特殊的需要描述信息的对象返回1、其他情况返回0。&#xA;一个对象在实现Parcelable接口时，需要通过Parcel类实现write和read的方法来完成序列化/反序列化。Parcel可以理解为实现各个对象序列化/反序列化的数据工具，其存储的是序列数据，其可以通过parcel.marshall()将自己转化为字节序列，用于在调试过程中查看parcel的序列化数据内容。简单来说，Parcel提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过Parcel可以从这块共享内存中读出字节流，并反序列化成对象进而使用。该过程如下图所示。&#xA;Parcel可以包含原始数据类型（通过各种对应的方法写入，比如writeInt()，writeFloat()等），也可以包含Parcelable对象（通过writeParcelable()等实现），其相关读写操作的实现可以在AOSP源码frameworks/base/core/java/android/os/Parcel.java中进一步查看。&#xA;Bundle数据结构 在 Andorid 中，Bundle类是一个类似HashMap的数据结构，其以键值对的形式存储数据。&#xA;可序列化的Parcelable对象一般不单独进行序列化传输，而是需要通过Bundle对象携带。例如， Android中进程间通信频繁使用的Intent对象中通常会携带一个Bundle对象，利用Intent.putExtra(key, value)方法，可以往Intent对应的Bundle对象中添加键值对(Key Value)。Key为String类型，而Value则可以为各种数据类型，包括Int、Boolean、String和Parcelable对象等等，Parcel类中维护着这些类型的信息及其序列化读写方法。&#xA;Bundle本身也是实现了Parcelable接口的，从序列化数据的角度来理解Bundle对象的内容：&#xA;开头是固定的：4字节Bundle长度 + 4字节魔数0x4C444E42 。 然后通过writeMap()存储实际的Bundle数据。先是采用parcel.writeInt()写入4字节的键值对数量，然后依次是每个key-value形式的键值对：key采用parcel.writeString()写入，即”4字节length+4字节对齐的string“的形式；value则采用parcel.writeValue()写入，writeValue时依次写入4字节Value类型和Value本身，Value类型的int值见frameworks/native/libs/binder/ParcelValTypes.h，Value本身的字节序列格式由Parcel.writeXXX(p, flags)决定。 参考Bundle风水，我们还可以把序列化后的Bundle对象存为文件进行研究。&#xA;事实上，frameworks/base/core/java/android/os/Parcel.java中也实现了readBundle()和writeBundle()函数，来对Bundle对象进行parcel的序列化读写操作。&#xA;题目概述 本题在Android Framework的代码中，以patch的方式添加了一个有漏洞的VulnParcelable类，代码如下所示。&#xA;public final class VulnParcelable implements Parcelable { private String TAG = &amp;#34;VulnParcelable&amp;#34;; private int opt; private int o1; private int o2; private byte[] mPayload; public VulnParcelable() { } // @UnsupportedAppUsage private VulnParcelable(Parcel in) { readFromParcel(in); } // 反序列化 // opt=0: 只读一个o1 // opt=1: 先读o2，然后读一个size，o2&amp;gt;0才会再读一个buf[size] public void readFromParcel(@NonNull Parcel in) { Log.</description>
    </item>
  </channel>
</rss>
